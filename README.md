### 字符串匹配

#### 单模式串匹配

##### BF(Brute Force)算法

暴力法，时间复杂度：O(n*m)

**js实现**

```js
function bf(strA, strB) {
    console.log(strA,strB);
    let i = 0, j = 0;
    let lenA = strA.length, lenB = strB.length;

    for (i = 0; i <= lenA-lenB; i ++) {
        for (j = 0; j < lenB; j ++) {
            if (strA[i + j] != strB[j]) {
                break;
            }
        }
        if (j == lenB) {
            return i;
        }
    }
    return -1;
}

let ans = bf('123456789', '345');
console.log(ans);
```

##### RK(Rabin-Krap)算法

RK 算法的思路：通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面我们会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。

RK算法复杂度(O(n))：哈希计算(O(n))和主串与模式串的哈希比较(O(n-m+1))。

##### BM(Boyer-Moore)算法

上述的两种算法算法是将模式串向后移动一位，BM算法的核心思想是一次将模式串向后移动多位。问题的关键在于怎么寻找到这种规律。BM 算法包含两部分，分别是坏字符规则（bad character rule）和好后缀规则（good suffix shift）。

1. 坏字符规则
   坏字符从模式串末尾往前倒序匹配。当发现某个字符无法匹配的时候，没有匹配的字符就称之为坏字符(主串中的字符)。

   <div style="text-align:center;font-size:12px;">
       <img src="./static/imgs/1587868212000.jpeg" />
       <span style="color:rgba(0,0,0,.45);">图片摘自极客时间王铮《数据结构预算法之美》专栏</span>
</div>
   
拿坏字符在模式串中查找，发现模式串中并不存在这个字符，此时，可以直接将模式串向后移动三位到 `c` 的后面的位置，再从模式串的末尾字符开始比较。
   
   <div style="text-align:center;font-size:12px;">
       <img src="./static/imgs/1587880674630.jpeg" />
       <span style="color:rgba(0,0,0,.45);">图片摘自极客时间王铮《数据结构预算法之美》专栏</span>
   </div>
   
   这是我们会发现出现了一个新的坏字符 `a` ，但模式串中存字符 `a` 。这种情况下模式串就在只能移动两位，让两个 `a` 上下对齐，然后在从末尾字符串开始，重新匹配。
   
   ...
   
   那么，每次模式串与主串无法匹配时，到底应该讲模式串向后滑动几位呢。其实，稍微想一下就应该能明白：如果坏字符在模式串中不存在，那么可以放心大胆地将整个模式串对齐到坏字符所在下标的后一位，反之，应该将模式串中 *离坏字符最近的* 相同字符移到与坏字符对齐的对方（移动的单位最小为原则，防止漏过）。即：当发生不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的最大下标记作 xi。如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。
   
   
   
   仅仅这样还不够，因为si-xi可能是负数。还需要好后缀原则。
   
2. 好后缀规则

   ......

